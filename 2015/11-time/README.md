# Работа со временем

Системные вызовы работы с временем были рассмотрены в лекции 6.

Тип `time_t`.
Тип `struct tm`.
Системный вызов `time`.
Библиотечные функции `localtime`, `gmtime`.
Библиотечная функция `mktime`.


В качестве основной службы времени ядро UNIX предоставляет счетчик секунд, прошедших от начала Эпохи – 00:00:00 1 января 1970 года по всеобщему скоординированному времени (UTC)
Значение счетчика представлено типом данных time_tи называется календарным временем. С помощью календарного времени можно представить как дату, так и время суток. ОС UNIX всегда отличалась от других системтем, что она (а) хранит время UTC, а неместное время, (б) автоматически выполняет преобразования, такие как переход на летнее время, и (в) хранит дату и время как единое целое.
Функция time возвращает текущее время и дату.
```c
#include <time.h>
time_t time(time_t *calptr);
```
Возвращает значение времени в случае успеха, –1 в случае ошибки.Функция всегда возвращает значение времени. Если в качестве аргумента calptr передается непустой указатель, то значение времени дополнительно записывается по указанному адресу.
Функция gettimeofdayдает более высокую точность, чем функция time (до микросекунд). Для некоторых приложений это очень важно.

```c
#include <sys/time.h>
int gettimeofday(struct timeval *restrict tp, void *restrict tzp);
```
Всегда возвращает значение 0.
Эта функция определена стандартом Single UNIX Specification как расширение XSI. Единственное допустимое значение аргумента tzp– NULL; любые другие значения могут привести к непредсказуемым результатам. Некоторые платформы поддерживают указание часового пояса через аргумент tzp, но это зависит от конкретной реализации и не определено в Single UNIX Specification.
Функция gettimeofdayсохраняет время, прошедшее от начала Эпохи до настоящего момента, по адресу tp. Это время представлено в виде структуры timeval, которая хранит секунды и микросекунды:
```c
struct timeval {
time_t tv_sec; /* секунды */
long tv_usec; /* микросекунды */
};
```
Как только получено целочисленное значение количества секунд, прошедших с начала Эпохи, как правило, вызывается одна из функций преобразования, которая переведет числовое значение в удобочитаемые время и дату.
Две функции, localtime и gmtime, преобразуют календарное время в структуру tm, состоящую из следующих элементов:

```c
struct tm { /* время, разбитое на составляющие */
int tm_sec; /* секунды от начала минуты: [0 -60] */
int tm_min; /* минуты от начала часа: [0 - 59] */
int tm_hour; /* часы от полуночи: [0 - 23] */
int tm_mday; /* дни от начала месяца: [1 - 31] */
int tm_mon; /* месяцы с января: [0 - 11] */
int tm_year; /* годы с 1900 года */
int tm_wday; /* дни с воскресенья: [0 - 6] */
int tm_yday; /* дни от начала года (1 января): [0 - 365] */
int tm_isdst; /* флаг перехода на летнее время: <0, 0, >0 */
};
```
Количество секунд может превышать 59, когда для коррекции времени вставляется дополнительная секунда. Обратите внимание, что отсчет всех компонентов, кроме дня месяца, начинается с 0. Флаг перехода на летнее время представлен положительным числом, если действует летнее время, 0 – если нет и отрицательным числом, если данная информация недоступна.
```c
#include <time.h>
struct tm *gmtime(const time_t *calptr);
struct tm *localtime(const time_t *calptr);
```
Функции localtimeи gmtimeотличаются тем, что первая преобразует календарное время в местное, учитывая при этом часовой пояс и переход на летнее время, а вторая разбивает календарное время UTC на составляющие.
Функция mktime принимает местное время в виде структуры tm и преобразует его в значение time_t.
```c
#include <time.h>
time_t mktime(struct tm *tmptr);

Возвращает календарное время в случае успеха, –1 в случае ошибки
```
Функции asctimeи ctimeвозвращают строку длиной 26 байт, которая напоминает вывод команды date(1):
```c
Tue Feb 10 18:27:38 2004\n\0
#include <time.h>
char *asctime(const struct tm *tmptr);
char *ctime(const time_t *calptr);

Обе возвращают указатель на строку, завершающуюся нулевым символом
```
Функции asctime в качестве аргумента передается структура tm, тогда как функции ctime– календарное время.
И наконец, последняя и самая сложная функция времени – strftime. Это printf подобная функция для представления временных значений.
```c
#include <time.h>
size_t strftime(char *restrict buf, size_t maxsize, const char *restrict format,const struct tm *restrict tmptr);

Возвращает количество символов, записанных в массив,если в нем достаточно места, в противном случае возвращает 0
```
Последний аргумент функции – указатель на структуру tm, содержащую время, которое должно быть представлено в виде отформатированной строки. 
Результат форматирования сохраняется в буфере buf, размер которого определяется аргументом maxsize. 
Если полученная в результате преобразования строка, включая завершающий нулевой символ, умещается в буфере, то функция возвращает длину полученной строки без завершающего нулевогосимвола. В противном случае возвращается 0.
Аргумент format управляет форматированием значения времени. Как и в случае с функцией printf, спецификаторы формата начинаются с символа процента, за которым следуют служебные символы. Все остальные символы встроке formatвыводятся без изменений. Два символа процента, следующие друг за другом, будут отображаться как один символ процента. В отличие от функции printf, каждый спецификатор формата генерирует на выходе строки
фиксированного размера – спецификаторы ширины поля вывода не предусмотрены.

Функция mktime 
```c
#include <time.h>
time_t mktime( struct tm * ptrtime );
```
Интерпретирует содержимое структуры tm, передаваемой в функцию в качестве аргумента через указатель на ptrtime в формат местного времени. Данная функция по некоторым исходным значениям времени восстанавливает значения остальных членов ptrtime, соответственно.
Исходные значения членов  структуры tm_wday и tm_yday из ptrtime игнорируются. Диапазоны значений для остальных  членов структуры ограничиваются их нормальными значениями (например, диапазон значений tm_mday находится между 1 и 31).
Объект, на который указывает ptrtime изменяется, а именно — инициализируются переменные-члены tm_wday и tm_yday, и изменяются значения других переменных-членов в пределах нормы, в соответствии с  указанным временем.

```c
//пример использования функции mktime: определить день недели
#include <iostream>
#include <ctime>
 
int main ()
{
  time_t rawtime;                                       // тип данных для хранения количества секунд
  struct tm * timeinfo;                                 // структура даты и времени
  int year, month ,day;
 
  char * weekday[] = { "Воскресенье", "Понедельник",
                       "Вторник", "Среда",
                       "Четверг", "Пятница", "Суббота"};
 
  //Ввод даты
  std::cout << "Введите год: ";    std::cin >> year;
  std::cout << "Введите месяц: "; std::cin >> month;
  std::cout << "Введите день: ";   std::cin >> day;
 
  // получить текущую информацию о дате и изменить её относительно введенной
  time( &rawtime );                              // текущая дата в секундах
  timeinfo = localtime( &rawtime );              // преобразовние текущей даты из секунд к нормальному виду
  timeinfo->tm_year = year - 1900;               // корректируем год
  timeinfo->tm_mon = month - 1;                  // корректируем значение месяца
  timeinfo->tm_mday = day;                       // введённый день
 
  mktime( timeinfo );                            // определить день недели
 
  std::cout << "День недели: " <<  weekday[timeinfo->tm_wday] << std::endl;
 
  return 0;
}
```